{
  "rules": [
    {
      "type": "prd",
      "content": "## 웹툰 다이어리 PRD\n\n### 1. 목표 및 비전\n\n*   **목표**: AI를 활용하여 사용자의 일상을 재미있는 4컷 만화로 만들어주는 혁신적인 다이어리 앱을 개발한다.\n*   **비전**: 모든 사람들이 쉽고 재미있게 자신의 일상을 기록하고 공유하며 소통하는 세상을 만든다.\n\n### 2. 타겟 사용자\n\n*   **주요 타겟 사용자**: 10대 학생, 20-30대 여성\n*   **사용자 특징**: 감성적, 소셜 미디어 활용 능숙, 자신을 표현하는 데 관심 많음\n\n### 3. 주요 기능\n\n*   **일기 작성 및 저장**: 텍스트로 일기를 작성하고 저장하는 기능\n*   **AI 기반 4컷 만화 생성**: 작성된 일기를 바탕으로 AI가 4컷 만화 이미지를 생성하는 기능\n    *   다양한 만화 스타일 제공 (귀여운 스타일, 코믹 스타일, 감성적인 스타일 등)\n*   **만화 이미지 다운로드**: 생성된 4컷 만화 이미지를 다운로드할 수 있는 기능\n*   **SNS 공유**: 생성된 4컷 만화 이미지를 SNS에 공유할 수 있는 기능\n*   **일기 및 만화 보관**: 작성한 일기와 생성된 만화 이미지를 앱 내에서 보관하고 언제든지 볼 수 있는 기능\n*   **일기 알림**: 매일 일기를 쓰도록 알림을 제공하는 기능 (시간 설정 가능)\n\n### 4. 상세 기능\n\n*   **일기 작성**: 텍스트 입력, 이미지 첨부, 위치 정보 추가 기능\n*   **AI 만화 생성**: 만화 스타일 선택, 만화 컷 편집 기능, 백그라운드(Background) 생성 지원\n*   **이미지 다운로드**: 다운로드 해상도 선택 기능\n*   **SNS 공유**: 다양한 SNS 플랫폼 연동 기능\n*   **일기 보관**: 날짜별, 키워드별 검색 기능\n*   **알림 설정**: 알림 시간 설정, 알림 내용 설정, AI 만화 생성 완료 시 앱 푸시메세지 발송 기능\n\n### 5. UI/UX 디자인\n\n*   **UI 컨셉**: 심플하고 직관적인 디자인, 트렌디하고 감각적인 디자인\n*   **주요 컬러**: 파스텔톤 컬러, 밝고 경쾌한 컬러\n*   **폰트**: 가독성이 좋은 폰트, 개성 있는 폰트\n\n### 6. 성능 및 기술 요구 사항\n\n*   **플랫폼**: iOS, Android\n*   **개발 언어**: Swift, Kotlin\n*   **AI 기술**: 자연어 처리 (NLP), 이미지 생성 (GAN)\n*   **서버**: 안정적인 서버 환경, 빠른 응답 속도\n\n### 7. 출시 전략\n\n*   **출시 시기**: 2024년 4분기\n*   **마케팅 전략**: SNS 마케팅, 인플루언서 마케팅, 앱 스토어 최적화 (ASO)\n\n### 8. 사용자 시나리오\n\n*   **시나리오 1**: 10대 학생이 학교에서 있었던 재미있는 일을 일기로 작성하고, AI가 생성한 만화 이미지를 친구들과 공유한다.\n*   **시나리오 2**: 20대 여성이 오늘 느꼈던 감정을 일기로 작성하고, AI가 생성한 감성적인 만화 이미지를 인스타그램에 업로드한다.\n*   **시나리오 3**: 30대 여성이 육아일기를 작성하고, AI가 생성한 귀여운 만화 이미지를 가족들과 공유한다.",
      "writedAt": "2025-09-30T09:08:53.336Z"
    },
    {
      "type": "architecture",
      "content": "# Technical Requirements Document (TRD)\n\n## 1. Executive Technical Summary\n- **Project Overview**: Flutter 프레임워크와 Supabase 백엔드를 활용하여 사용자 일상 기반의 4컷 만화를 생성하는 모바일 다이어리 앱을 개발합니다. AI 기반 만화 생성 기능은 Python 기반 서버에서 처리하며, 생성된 만화 이미지는 Supabase Storage에 저장됩니다.\n- **Core Technology Stack**: Flutter, Supabase, Supabase Auth, In-App Purchases, Python\n- **Key Technical Objectives**:\n    - 빠른 응답 속도 및 안정적인 서비스 제공\n    - 확장 가능한 아키텍처 설계\n    - 사용자 데이터 보안 및 개인 정보 보호\n- **Critical Technical Assumptions**:\n    - 안정적인 인터넷 연결 환경\n    - AI 모델의 정확도 및 성능 확보\n    - Supabase 서비스의 안정적인 운영\n\n## 2. Tech Stack\n\n| Category          | Technology / Library        | Reasoning (Why it's chosen for this project) |\n| ----------------- | --------------------------- | -------------------------------------------- |\n| Platform          | Flutter                     | iOS 및 Android 플랫폼 동시 개발 및 유지 보수 용이, 빠른 개발 속도, 풍부한 UI 라이브러리 제공 |\n| Backend           | Supabase                    | 서버리스 아키텍처, 인증, 데이터베이스, 스토리지 기능 통합 제공, 빠른 개발 및 배포, 확장성 용이 |\n| Authentication    | Supabase Auth               | 안전하고 간편한 사용자 인증 기능 제공 (소셜 로그인, 이메일/비밀번호 로그인 등) |\n| Database          | Supabase PostgreSQL          | 안정적인 데이터 저장 및 관리, 확장성 용이, ACID 트랜잭션 지원 |\n| Storage           | Supabase Storage            | 이미지 및 파일 저장 및 관리 용이, CDN 통합 제공 |\n| In-App Purchases | Flutter in_app_purchase plugin | iOS 및 Android 인앱 결제 기능 통합 및 관리 용이 |\n| AI Backend        | Python                      | 머신러닝 및 딥러닝 라이브러리 풍부, AI 모델 개발 및 배포 용이 |\n| NLP Library        | spaCy, NLTK                 | 자연어 처리 기능 제공, 일기 내용 분석 및 키워드 추출 |\n| Image Generation   | DALL-E 3 API, Stable Diffusion | 텍스트 기반 이미지 생성 기능 제공, 다양한 스타일의 만화 이미지 생성 |\n| API Framework     | FastAPI                     | Python 기반 고성능 API 개발 프레임워크, 빠른 개발 및 배포 |\n\n## 3. System Architecture Design\n\n### Top-Level building blocks\n- **Frontend (Flutter Mobile App)**:\n    - 사용자 인터페이스 및 사용자 경험 제공\n    - 일기 작성, 만화 생성 요청, SNS 공유 등의 기능 제공\n    - Supabase Auth를 통한 사용자 인증 및 관리\n    - In-App Purchases를 통한 결제 처리\n- **Backend (Supabase)**:\n    - 데이터베이스 (PostgreSQL)를 통한 일기 및 만화 데이터 저장 및 관리\n    - Supabase Storage를 통한 이미지 파일 저장 및 관리\n    - API Gateway를 통한 API 요청 처리 및 라우팅\n- **AI Server (Python FastAPI)**:\n    - 일기 내용을 기반으로 AI 모델을 통해 4컷 만화 이미지 생성\n    - DALL-E 3 API 또는 Stable Diffusion 모델 활용\n    - 생성된 이미지를 Supabase Storage에 저장\n- **External Services**:\n    - SNS 플랫폼 API (Facebook, Instagram, Twitter 등)를 통한 만화 이미지 공유 기능 제공\n    - Apple App Store 및 Google Play Store를 통한 앱 배포 및 관리\n\n### Top-Level Component Interaction Diagram\n\n```mermaid\ngraph LR\n    A[Flutter Mobile App] --> B(Supabase Backend)\n    B --> C(PostgreSQL Database)\n    B --> D(Supabase Storage)\n    A --> E[Python FastAPI AI Server]\n    E --> D\n    A --> F[SNS Platforms]\n    A --> G[App Stores]\n```\n\n- Flutter Mobile App은 Supabase Backend를 통해 사용자 인증, 데이터 저장/조회, 결제 처리 등의 기능을 수행합니다.\n- Flutter Mobile App은 Python FastAPI AI Server에 일기 내용을 전달하여 4컷 만화 이미지 생성을 요청하고, 생성된 이미지를 Supabase Storage에서 다운로드합니다.\n- Flutter Mobile App은 SNS Platforms API를 통해 생성된 만화 이미지를 공유합니다.\n- Flutter Mobile App은 App Stores를 통해 배포 및 업데이트됩니다.\n\n### Code Organization & Convention\n**Domain-Driven Organization Strategy**\n- **Domain Separation**: 사용자 관리, 일기 관리, 만화 생성, 결제 처리 등으로 도메인 분리\n- **Layer-Based Architecture**: Presentation (UI), Business Logic, Data Access, Infrastructure 레이어로 분리\n- **Feature-Based Modules**: 각 기능별 모듈화 (예: 일기 작성 모듈, 만화 생성 모듈, SNS 공유 모듈)\n- **Shared Components**: 공통 유틸리티, 타입, 재사용 가능한 컴포넌트를 별도 모듈로 관리\n\n**Universal File & Folder Structure**\n```\n/\n├── lib/\n│   ├── core/                      # 공통 유틸리티, 상수, 타입 정의\n│   │   ├── utils/\n│   │   ├── constants/\n│   │   └── models/\n│   ├── features/                 # 기능별 모듈\n│   │   ├── diary/                 # 일기 관련 기능\n│   │   │   ├── presentation/     # UI 컴포넌트\n│   │   │   ├── domain/           # 비즈니스 로직\n│   │   │   ├── data/             # 데이터 접근 및 관리\n│   │   │   └── models/           # 일기 관련 데이터 모델\n│   │   ├── comic/                 # 만화 생성 관련 기능\n│   │   │   ├── presentation/\n│   │   │   ├── domain/\n│   │   │   ├── data/\n│   │   │   └── models/\n│   │   ├── auth/                  # 사용자 인증 관련 기능\n│   │   │   ├── presentation/\n│   │   │   ├── domain/\n│   │   │   ├── data/\n│   │   │   └── models/\n│   │   └── ...\n│   ├── widgets/                   # 재사용 가능한 위젯\n│   ├── services/                  # 외부 서비스 연동\n│   │   ├── supabase_service.dart\n│   │   ├── ai_server_service.dart\n│   │   └── ...\n│   └── app.dart                   # 앱 시작점\n├── pubspec.yaml\n├── README.md\n└── ...\n```\n\n### Data Flow & Communication Patterns\n- **Client-Server Communication**: Flutter 앱은 Supabase Backend API를 통해 데이터를 요청하고 응답을 받습니다. (RESTful API)\n- **Database Interaction**: Supabase PostgreSQL 데이터베이스는 Supabase ORM을 통해 데이터를 CRUD (Create, Read, Update, Delete) 합니다.\n- **External Service Integration**: SNS 플랫폼 API는 Flutter 앱에서 직접 호출하거나 Supabase Backend를 통해 호출될 수 있습니다. AI Server API는 Flutter 앱 또는 Supabase Backend에서 호출될 수 있습니다.\n- **Real-time Communication**: 실시간 알림 기능은 Supabase Realtime 또는 Firebase Cloud Messaging (FCM)을 통해 구현될 수 있습니다.\n- **Data Synchronization**: 데이터 일관성을 위해 트랜잭션 및 optimistic locking 패턴을 적용합니다.\n\n## 4. Performance & Optimization Strategy\n- 이미지 최적화: 이미지 크기 및 해상도 최적화, CDN 활용\n- 캐싱 전략: API 응답 캐싱, 이미지 캐싱, 데이터베이스 쿼리 캐싱\n- 비동기 처리: 백그라운드 작업 활용, UI 스레드 블로킹 방지\n- 데이터베이스 쿼리 최적화: 인덱싱, 쿼리 튜닝, 배치 처리\n- AI 모델 최적화: 모델 경량화, 추론 속도 향상, GPU 활용\n\n## 5. Implementation Roadmap & Milestones\n### Phase 1: Foundation (MVP Implementation)\n- **Core Infrastructure**: Flutter 개발 환경 구축, Supabase 프로젝트 설정, AI Server 환경 구축\n- **Essential Features**: 일기 작성 및 저장 기능, AI 기반 4컷 만화 생성 기능, 만화 이미지 다운로드 기능, 사용자 인증 기능\n- **Basic Security**: 사용자 데이터 암호화, API 보안 설정\n- **Development Setup**: 개발 환경 설정, CI/CD 파이프라인 구축 (GitHub Actions, GitLab CI 등)\n- **Timeline**: 8주\n\n### Phase 2: Feature Enhancement\n- **Advanced Features**: SNS 공유 기능, 일기 및 만화 보관 기능, 일기 알림 기능, 인앱 결제 기능\n- **Performance Optimization**: 이미지 최적화, 캐싱 전략 적용, 데이터베이스 쿼리 최적화\n- **Enhanced Security**: 보안 취약점 점검 및 수정, 개인 정보 보호 강화\n- **Monitoring Implementation**: 성능 모니터링, 오류 로깅, 사용량 분석 (Sentry, Firebase Analytics 등)\n- **Timeline**: 12주\n\n## 6. Risk Assessment & Mitigation Strategies\n### Technical Risk Analysis\n- **Technology Risks**: AI 모델의 정확도 및 성능 부족, Supabase 서비스 장애, 외부 API 의존성\n- **Performance Risks**: 느린 응답 속도, 높은 트래픽으로 인한 서버 과부하\n- **Security Risks**: 사용자 데이터 유출, API 공격, 인앱 결제 보안 취약점\n- **Integration Risks**: SNS 플랫폼 API 변경, AI Server API 호환성 문제\n- **Mitigation Strategies**:\n    - AI 모델 성능 개선을 위한 지속적인 학습 및 튜닝\n    - Supabase 서비스 장애 대비 백업 및 복구 시스템 구축\n    - 외부 API 변경에 대한 모니터링 및 대응 계획 수립\n    - 성능 테스트 및 부하 테스트를 통한 성능 병목 지점 파악 및 개선\n    - 보안 취약점 점검 및 코드 리뷰를 통한 보안 강화\n    - API 버전 관리 및 호환성 테스트를 통한 API 호환성 유지\n\n### Project Delivery Risks\n- **Timeline Risks**: 개발 일정 지연, 기능 구현 난이도 증가\n- **Resource Risks**: 개발 인력 부족, 기술 전문가 부족\n- **Quality Risks**: 코드 품질 저하, 테스트 부족\n- **Deployment Risks**: 배포 과정에서의 오류 발생, 환경 설정 문제\n- **Contingency Plans**:\n    - 개발 일정 지연에 대한 대비책 마련 (예: 기능 축소, 추가 인력 투입)\n    - 개발 인력 부족에 대한 대비책 마련 (예: 외부 전문가 활용, 교육 프로그램 운영)\n    - 코드 품질 저하 방지를 위한 코드 리뷰 및 테스트 강화\n    - 배포 과정에서의 오류 발생 대비 자동화된 배포 시스템 구축 및 테스트 환경 구축\n",
      "writedAt": "2025-09-30T09:08:53.336Z"
    },
    {
      "type": "guideline",
      "content": "# Webtoon Diary App - Code Guidelines\n\n## 1. Project Overview\n\nThis project is a mobile diary application that leverages Flutter for the frontend, Supabase for the backend (including authentication, database, and storage), and Python (FastAPI) for the AI-powered comic generation. The app allows users to create diary entries, which are then transformed into 4-panel comic strips using AI.\n\nKey Architectural Decisions:\n\n*   **Flutter**: Cross-platform mobile development for iOS and Android.\n*   **Supabase**: Backend-as-a-Service (BaaS) for authentication, database, and storage.\n*   **Python FastAPI**: API framework for the AI comic generation service.\n*   **Domain-Driven Design**: Organization around core business domains.\n\n## 2. Core Principles\n\n*   **Maintainability**: Code should be easy to understand, modify, and extend.\n*   **Readability**: Code should be clear and self-documenting.\n*   **Testability**: Code should be designed to be easily tested (unit, integration, and UI).\n*   **Performance**: Code should be efficient and optimized for speed and resource usage.\n*   **Security**: Code should be secure and protect user data.\n\n## 3. Language-Specific Guidelines\n\n### 3.1. Flutter (Dart)\n\n#### File Organization and Directory Structure\n\nFollow the Feature-Based Modules structure, as outlined in the TRD:\n\n```\n/lib\n├── core/                      # 공통 유틸리티, 상수, 타입 정의\n│   ├── utils/\n│   ├── constants/\n│   └── models/\n├── features/                 # 기능별 모듈\n│   ├── diary/                 # 일기 관련 기능\n│   │   ├── presentation/     # UI 컴포넌트\n│   │   ├── domain/           # 비즈니스 로직\n│   │   ├── data/             # 데이터 접근 및 관리\n│   │   └── models/           # 일기 관련 데이터 모델\n│   ├── comic/                 # 만화 생성 관련 기능\n│   │   ├── presentation/\n│   │   ├── domain/\n│   │   ├── data/\n│   │   └── models/\n│   ├── auth/                  # 사용자 인증 관련 기능\n│   │   ├── presentation/\n│   │   ├── domain/\n│   │   ├── data/\n│   │   └── models/\n│   └── ...\n├── widgets/                   # 재사용 가능한 위젯\n├── services/                  # 외부 서비스 연동\n│   ├── supabase_service.dart\n│   ├── ai_server_service.dart\n│   └── ...\n└── app.dart                   # 앱 시작점\n```\n\n#### Import/Dependency Management\n\n*   **MUST** use explicit imports.\n*   **MUST** group imports into: Dart SDK, Flutter packages, third-party packages, and project-local files.\n*   **MUST** sort imports alphabetically within each group.\n\n```dart\n// Dart SDK imports\nimport 'dart:async';\n\n// Flutter package imports\nimport 'package:flutter/material.dart';\n\n// Third-party package imports\nimport 'package:supabase_flutter/supabase_flutter.dart';\n\n// Project imports\nimport 'package:webtoon_diary/core/utils/string_utils.dart';\nimport 'package:webtoon_diary/features/auth/domain/user_repository.dart';\n```\n\n#### Error Handling Patterns\n\n*   **MUST** use `try-catch` blocks for handling potential exceptions.\n*   **MUST** provide informative error messages.\n*   **MUST** use `FutureBuilder` or `StreamBuilder` to handle asynchronous operations and display appropriate loading/error states.\n\n```dart\nFuture<void> fetchData() async {\n  try {\n    final response = await Supabase.instance.client.from('diaries').select('*');\n    // Process data\n  } catch (e) {\n    print('Error fetching data: $e');\n    // Display error message to the user\n  }\n}\n```\n\n### 3.2. Python (FastAPI)\n\n#### File Organization and Directory Structure\n\n```\n/app\n├── main.py          # FastAPI application entry point\n├── api/             # API route definitions\n│   ├── endpoints/\n│   │   ├── comic.py   # Comic generation API endpoints\n│   │   └── ...\n│   ├── models/\n│   │   ├── diary.py   # Diary data models\n│   │   └── ...\n│   └── utils.py     # Utility functions for API routes\n├── services/        # Business logic and external service integrations\n│   ├── ai_service.py   # AI model interaction\n│   └── supabase_service.py # Supabase interaction\n├── core/            # Core utilities and configurations\n│   ├── config.py     # Application configuration\n│   └── security.py   # Security-related functions\n└── tests/           # Unit and integration tests\n    ├── api/\n    ├── services/\n    └── ...\n```\n\n#### Import/Dependency Management\n\n*   **MUST** use explicit imports.\n*   **MUST** follow PEP 8 guidelines for import ordering.\n*   **MUST** use a virtual environment (e.g., `venv`) to manage dependencies.\n*   **MUST** use `requirements.txt` to track dependencies.\n\n```python\n# Standard library imports\nimport os\n\n# Third-party library imports\nfrom fastapi import FastAPI, HTTPException\nfrom supabase import create_client, Client\n\n# Local application imports\nfrom app.api.models import DiaryEntry\nfrom app.services.ai_service import generate_comic\nfrom app.core.config import settings\n```\n\n#### Error Handling Patterns\n\n*   **MUST** use `try-except` blocks for handling potential exceptions.\n*   **MUST** raise appropriate HTTP exceptions using `fastapi.HTTPException`.\n*   **MUST** log errors using a logging library (e.g., `logging`).\n\n```python\nfrom fastapi import FastAPI, HTTPException\nimport logging\n\nlogger = logging.getLogger(__name__)\n\nasync def get_diary_entry(diary_id: int):\n    try:\n        # Attempt to retrieve diary entry from database\n        diary_entry = await database.fetch_one(\"SELECT * FROM diaries WHERE id = :diary_id\", {\"diary_id\": diary_id})\n        if diary_entry is None:\n            raise HTTPException(status_code=404, detail=\"Diary entry not found\")\n        return diary_entry\n    except Exception as e:\n        logger.error(f\"Error retrieving diary entry: {e}\")\n        raise HTTPException(status_code=500, detail=\"Internal server error\")\n```\n\n### 3.3. Supabase\n\n*   **MUST** use the Supabase client libraries for Dart and Python.\n*   **MUST** handle authentication securely using Supabase Auth.\n*   **MUST** use Row Level Security (RLS) policies to control data access.\n*   **MUST** validate data on the client-side and server-side before storing it in the database.\n\n## 4. Code Style Rules\n\n### MUST Follow:\n\n*   **Naming Conventions**:\n    *   **Classes**: Use `PascalCase`. (e.g., `DiaryEntry`, `ComicGenerator`)\n    *   **Functions/Methods**: Use `camelCase`. (e.g., `fetchData`, `generateComic`)\n    *   **Variables**: Use `camelCase`. (e.g., `diaryText`, `comicImageURL`)\n    *   **Constants**: Use `UPPER_SNAKE_CASE`. (e.g., `DEFAULT_IMAGE_SIZE`, `API_ENDPOINT`)\n    *   **Files**: Use `snake_case`. (e.g., `diary_service.dart`, `comic_api.py`)\n    *   **Rationale**: Consistency improves readability and predictability.\n*   **Comments**:\n    *   **MUST** comment complex logic and algorithms.\n    *   **MUST** use docstrings for classes, functions, and methods.\n    *   **MUST** keep comments up-to-date with the code.\n    *   **Rationale**: Comments aid in understanding the code's purpose and functionality.\n*   **Code Formatting**:\n    *   **MUST** use the official Dart formatter (`dart format`) and Python formatter (`black`) to ensure consistent code formatting.\n    *   **MUST** configure IDEs to automatically format code on save.\n    *   **Rationale**: Consistent formatting enhances readability and reduces visual noise.\n*   **Error Handling**:\n    *   **MUST** handle potential errors gracefully and provide informative error messages to the user.\n    *   **MUST** log errors for debugging and monitoring purposes.\n    *   **Rationale**: Robust error handling prevents crashes and improves the user experience.\n*   **Testing**:\n    *   **MUST** write unit tests for all critical components and functions.\n    *   **MUST** write integration tests to verify the interaction between different modules.\n    *   **MUST** use mock objects and test doubles to isolate units under test.\n    *   **Rationale**: Testing ensures code correctness and prevents regressions.\n*   **Security**:\n    *   **MUST** sanitize user inputs to prevent injection attacks.\n    *   **MUST** use secure authentication and authorization mechanisms.\n    *   **MUST** protect sensitive data using encryption.\n    *   **Rationale**: Security is paramount to protect user data and prevent unauthorized access.\n*   **State Management (Flutter)**:\n    *   **MUST** use a suitable state management solution (e.g., Provider, Riverpod, BLoC) for managing application state.\n    *   **MUST** separate UI logic from business logic.\n    *   **Rationale**: Proper state management improves code organization, testability, and maintainability.\n*   **API Design (Python FastAPI)**:\n    *   **MUST** follow RESTful principles for API design.\n    *   **MUST** use appropriate HTTP methods (GET, POST, PUT, DELETE).\n    *   **MUST** use JSON for data serialization and deserialization.\n    *   **MUST** use OpenAPI (Swagger) for API documentation.\n    *   **Rationale**: Consistent API design improves usability and maintainability.\n\n### MUST NOT Do:\n\n*   **Global Variables**:\n    *   **MUST NOT** use global variables except for truly constant values.\n    *   **Rationale**: Global variables introduce state and make code harder to reason about and test.\n*   **Nested Callbacks (Callback Hell)**:\n    *   **MUST NOT** create deeply nested callbacks.\n    *   **MUST** use `async/await` or `Future.then` to handle asynchronous operations in a more readable way.\n    *   **Rationale**: Callback hell makes code difficult to read and maintain.\n*   **Hardcoded Values**:\n    *   **MUST NOT** hardcode values directly in the code.\n    *   **MUST** use constants or configuration files to store values that may change.\n    *   **Rationale**: Hardcoded values make code less flexible and harder to maintain.\n*   **Ignoring Errors**:\n    *   **MUST NOT** ignore errors or exceptions.\n    *   **MUST** handle errors appropriately and log them for debugging purposes.\n    *   **Rationale**: Ignoring errors can lead to unexpected behavior and make it difficult to diagnose problems.\n*   **Over-Engineering**:\n    *   **MUST NOT** over-engineer solutions or introduce unnecessary complexity.\n    *   **MUST** keep the code simple and focused on the problem at hand.\n    *   **Rationale**: Over-engineering makes code harder to understand and maintain.\n*   **Unnecessary Comments**:\n    *   **MUST NOT** write comments that simply restate the code.\n    *   **MUST** focus on explaining the *why* rather than the *what*.\n    *   **Rationale**: Unnecessary comments clutter the code and make it harder to read.\n*   **Complex State Management (Flutter)**:\n    *   **MUST NOT** implement overly complex state management solutions for simple UI elements. Use `StatefulWidget` for simple UI state.\n    *   **Rationale**: Simplicity is a virtue.\n\n## 5. Architecture Patterns\n\n*   **Component/module structure guidelines**:  As defined in the TRD use Domain-Driven Organization Strategy.\n*   **Data flow patterns**: Flutter App -> Supabase Backend (API) or Flutter App -> Python FastAPI AI Server -> Supabase Backend (API).\n*   **State management conventions**: Use Provider, Riverpod, or BLoC for managing application state.\n*   **API design standards**: RESTful API principles, JSON for data serialization, OpenAPI documentation.\n\n## Example Code Snippets\n\n```dart\n// MUST: Using async/await for asynchronous operations\nFuture<String> fetchComicImage(String diaryText) async {\n  try {\n    final response = await aiService.generateComic(diaryText);\n    return response.imageUrl;\n  } catch (e) {\n    print('Error generating comic: $e');\n    return null;\n  }\n}\n```\n\n```dart\n// MUST NOT: Callback hell\nvoid fetchData() {\n  api.getData(\n    (data) {\n      processData(\n        data,\n        (result) {\n          updateUI(result);\n        },\n      );\n    },\n  );\n}\n\n// MUST: Refactor using async/await\nFuture<void> fetchDataAsync() async {\n  final data = await api.getDataAsync();\n  final result = await processDataAsync(data);\n  updateUI(result);\n}\n```\n\n```python\n# MUST: Handling exceptions in FastAPI\nfrom fastapi import FastAPI, HTTPException\n\napp = FastAPI()\n\n@app.get(\"/items/{item_id}\")\nasync def read_item(item_id: int):\n    try:\n        # Simulate database lookup\n        if item_id > 100:\n            raise ValueError(\"Item ID too large\")\n        return {\"item_id\": item_id}\n    except ValueError as e:\n        raise HTTPException(status_code=400, detail=str(e))\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=\"Internal server error\")\n```\n\n```python\n# MUST NOT: Ignoring exceptions\ndef process_data(data):\n    try:\n        result = 10 / len(data)  # Potential ZeroDivisionError\n        return result\n    except:  # Bare except clause - AVOID!\n        return None\n\n# MUST: Handle specific exceptions\ndef process_data(data):\n    try:\n        result = 10 / len(data)\n        return result\n    except ZeroDivisionError:\n        print(\"Error: Data list is empty\")\n        return None\n    except TypeError:\n        print(\"Error: Invalid data type\")\n        return None\n```\n",
      "writedAt": "2025-09-30T09:08:53.336Z"
    },
    {
      "type": "design-guide",
      "content": "# 웹툰 다이어리 Design Guide\n\n## 1. Overall Mood (전체적인 무드)\n- 컨셉: Fun and Trendy(밝고 경쾌한 캐주얼 무드) + LINE WEBTOON의 명료함을 믹스\n- 타겟 사용자: 10대 학생, 20–30대 여성(감성적, SNS 공유 친화)\n- 톤앤매너: 상쾌한 민트 포인트, 파스텔 액센트, 라운디드 요소, 가벼운 모션\n- 온도/채도: 쿨 톤 중심에 약간의 따뜻함, 채도 중상, 명도 높음\n- 핵심 경험: 단일 피드에서 일상을 스르륵 회상 → 4컷 만화로 가볍게 생성/공유\n\n## 2. Reference Service (참조 서비스)\n- Name: LINE WEBTOON\n- Description: 글로벌 웹툰 플랫폼\n- Design Mood: 화이트 베이스, 선명한 그린 포인트, 단순하고 직관적인 컴포넌트\n- Primary Color: #00D564\n- Secondary Color: #121212\n\n## 3. Color & Gradient (색상 & 그라데이션)\n- Primary Color: Fresh Mint Green #00D884\n- Secondary Color: Soft Lilac #C9A8FF\n- Accent 1: Peach Pink #FF8FB3\n- Accent 2: Sky Blue #7EC8FF\n- Accent 3: Sunny Yellow #FFE36E\n- Background: #FFFFFF / Off White #FAFBFF\n- Surface: Card Surface #FFFFFF\n- Text Primary: #111318\n- Text Secondary: #5B5B66\n- Line/Divider: #EDECF2\n- Grayscale: #111318, #2A2E37, #6B7280, #C9CDD6, #E9ECF2, #F6F7FB\n- Status: Success #00C97A / Warning #FFA500 / Error #FF5A5F\n- Mood: Cool leaning with warm accents / Medium-high saturation\n\nColor Usage(권장 비율)\n- Primary(민트): 15% — 핵심 CTA, FAB, 주요 강조 라벨\n- Secondary(라일락): 10% — 감정 태그, 보조 CTA, 상태 뱃지\n- Accents(피치/스카이/옐로): 10% — 그래픽, 배지/보상, 온보딩/튜토리얼 강조\n- Background/Surface: 55% — 넓은 화이트, 오프화이트\n- Text/Lines: 10% — 텍스트, 구분선 최소화\n\nRecommended Gradients\n- Mint → Lilac: #00D884 → #C9A8FF (온보딩 히어로, 공유 배너)\n- Mint → Sky: #00D884 → #7EC8FF (메인 CTA 영역, 생성 완료 강조)\n\nAccessibility\n- Primary(#00D884) 위 텍스트는 #FFFFFF 사용, 굵기 SemiBold 이상, 필요 시 8% 그림자\n- 모든 텍스트 대비 AA 이상(본문 4.5:1, 대텍스트 3:1) 유지\n\n## 4. Typography & Font (타이포그래피 & 폰트)\n- 기본 폰트: Pretendard 또는 SUIT (iOS/Android 모두 가독성 우수)\n- 대체 폰트: Noto Sans KR(시스템 폰트 대비 호환성)\n- Letter spacing: 기본 0% (캡션/모노 요소는 -1%까지 허용)\n- Paragraph spacing: 본문 4–8px, 카드 내 8–12px\n\nType Scale(모바일 기준)\n- H1: 28px, Bold, LH 36\n- H2: 24px, SemiBold, LH 32\n- H3: 20px, SemiBold, LH 28\n- Subtitle: 18px, Medium, LH 26\n- Body 1: 16px, Regular, LH 24\n- Body 2: 14px, Regular, LH 22\n- Button: 16px, SemiBold, LH 20, All Caps 사용 지양(친근 톤 유지)\n- Caption: 12–13px, Regular, LH 18\n- Number tag(뱃지): 12px, SemiBold\n\n## 5. Layout & Structure (레이아웃 & 구조)\n네비게이션 원칙\n- 단일 메인 피드(홈+보관함 통합), 하단 탭 없음\n- 우측 상단 프로필 버튼, 우측 하단 FAB(생성)\n- 상단 앱바: 좌측 로고/“오늘의 일기” 타이틀, 중앙 비움, 우측 프로필\n\n상단 영역\n- 앱바 하단 세그먼트: “오늘 · 이번 주 · 전체”\n- 필터/정렬 칩 행: 스타일, 감정, 즐겨찾기, 첨부유무 / 정렬(최신순, 오래된순, 스타일별, 즐겨찾기 우선)\n- 고급 필터: 바텀시트(날짜 범위 캘린더, 자주 쓰는 키워드 추천 칩)\n\n메인 피드\n- 무한 스크롤, 월 단위 스티키 헤더\n- 카드 구성: 날짜/감정칩 → 일기 요약(최대 2줄) → 4컷 썸네일 → 액션(공유/다운로드/재생성)\n- 롱프레스: 멀티선택(일괄 다운로드/공유/삭제/배치 재생성)\n- 빠른 이동: “오늘로 가기” 미니 FAB(하단 스크롤 시 노출)\n\n생성 진입\n- FAB: 우하단 고정, 스크롤 다운 시 축소, 업 시 재등장\n- 길게 누르기/스피드 다이얼: 빠른 생성, 템플릿 선택, 고급 편집, 이미지에서 시작\n\n프로필\n- 설정: 알림 시간, SNS 연동, 기본 해상도, 사용자 프리셋(스타일+폰트+톤), 접근성\n- 반응 요약: SNS 공유 후 좋아요/댓글 요약 카드(과시 압박 없이 가볍게)\n\n그리드 & 스페이싱\n- Spacing: 8dp 기본 단위(4/8/12/16/24/32dp 사용)\n- 카드 코너: 16dp 라운드\n- 이미지 코너: 12dp 라운드(4컷 프리뷰는 각 12dp)\n- 안전영역: iOS/Android 노치 고려 상/하 여백 준수\n\n## 6. Visual Style (비주얼 스타일)\n아이콘\n- 둥근 모서리, 라인+솔리드 혼합\n- 기본 선 두께 2px, 크기 24px/32px, 컬러는 텍스트 대비 규칙 준수\n- 상태/강조 아이콘에 Primary/Secondary 제한적 사용\n\n일러스트/스티커\n- 파스텔 그라데이션 배경 + 심플 쉐이프\n- 감정 이모지 기반 스티커 팩 제공(😊😮😢✨ 등)\n- 온보딩/Empty State: Mint→Lilac, Mint→Sky 그라데이션 사용\n\n이미지/만화 스타일\n- 4컷 프레임 굵기 1px, 코너 12dp, 그림자 8dp/10% 투명\n- 말풍선: 라운드 12dp, 테일은 짧고 둥글게, 본문 Body2 크기\n- 스타일 테마: 귀여움/코믹/감성(썸네일 미리보기 제공)\n\n쉐도우\n- 레벨 1(카드): 0,4,12 / #000 10%\n- 레벨 2(FAB/시트): 0,8,24 / #000 14%\n\n## 7. UX Guide (UX 가이드)\n타겟: Both(초보자+전문가) 듀얼-레일\n\n공통\n- 4컷 생성 CTA 상시 접근(FAB 고정)\n- 자동 저장 드래프트, 2탭 공유(최근 플랫폼 기억)\n- 생성 대기 스켈레톤 + ETA, 완료 푸시 알림(백그라운드 처리)\n- 빈 화면: 샘플 만화 + 원탭 템플릿(학교/감정/육아)\n\n초보자 레일\n- 온보딩 3스텝: 선호 스타일 → 알림 시간 → 샘플 생성 체험\n- 가이드 모드: “이렇게 써볼까요?” 제안 문장, 감정 태그 추천\n- 단계형 플로우: 일기 입력 → 스타일 선택 → 미리보기 → 공유\n- 마이크로카피: “와, 오늘의 일이 만화가 됐어요! 🎉”\n\n전문가 레일\n- 퀵 캡처: 홈 상단 “빠른 일기” 필드 + 최근 스타일 자동 적용(2탭 생성)\n- 고급 편집: 컷 순서/말풍선/톤 조정, 프롬프트 세부값 저장\n- 라이브러리: 멀티 액션, 배치 재생성, 해상도 일괄 설정\n- 제스처: 좌스와이프=공유, 우스와이프=재생성(사용자 설정 on/off)\n- 상태: 생성 큐 표시, 실패 시 자동 재시도\n\n발견성 보완(탭 없는 구조)\n- 프로필 아이콘 배지(알림/반응)\n- 필터 바 리빌 인터랙션(아래 스와이프로 크게 펼치기)\n- 첫 3회 세션 가이드 카드(필터/날짜 활용 안내)\n\nUser Journey 개선 매핑\n- 온보딩 간소화/개인화: 3단계 + 샘플 생성\n- 자동 저장/템플릿: 홈 첫 화면 제공\n- 생성 속도 향상: ETA, 백그라운드 처리\n- 공유 간소화/다양 플랫폼: 최근 공유 상단 고정\n- 피드백 강화: 댓글/반응 요약 알림\n\n## 8. UI Component Guide (UI 컴포넌트 가이드)\nButtons\n- Primary: Height 48, 코너 12, BG #00D884, Text #FFFFFF\n- Secondary: Height 48, 코너 12, Stroke #C9A8FF 1px, Text #111318\n- Tertiary(Text): Padding 8–12, 컬러 #111318\n- States: Hover(웹), Pressed(-4% 명도), Disabled(40% 알파)\n\nFAB\n- Size: 56x56, 코너 28, BG #00D884, 아이콘 #FFFFFF\n- 스크롤 동작: Down 시 축소/페이드, Up 시 재등장\n- 롱프레스/스피드 다이얼: 빠른 생성/템플릿/고급 편집\n\nChips\n- Filter Chip: 32 높이, 라운드 16, 선택 시 BG #C9A8FF, Text #111318\n- Emotion Chip: 이모지 + 텍스트, BG 파스텔 톤 엷게\n\nInputs\n- 일기 입력: Outline 1px #EDECF2, Focus #00D884 2px\n- 오류: Border #FF5A5F, 헬프텍스트 #FF5A5F\n\nCards\n- 기본 카드: 라운드 16, 그림자 레벨 1, 내부 패딩 16\n- 일기 카드: 날짜/감정칩 → 요약 → 4컷 프리뷰 → 액션(공유/다운/재생성)\n\nNavigation\n- Top App Bar: 좌 타이틀, 우 프로필(뱃지 가능), 중앙 비움\n- Bottom Sheet: 필터/정렬/해상도/공유 옵션\n- Dialog: 삭제/초기화 등 결정형, 코너 20, 버튼 2개\n\nFeedback\n- Toast: 하단, 2초, 예) “다운로드가 시작됐어요”\n- Snack/Inline: 액션 포함 시 4초\n- Empty state: 일러스트 + “샘플로 시작하기” 버튼\n\nProgress\n- Linear: 생성 단계(1/4→4/4), 민트 컬러\n- Skeleton: 카드/썸네일 플레이스홀더\n\nBadges\n- 알림 배지: 프로필 아이콘 우상단 8dp, Sunny Yellow 사용\n\nAccessibility\n- 터치 영역 44px+, 포커스 인디케이터 2px\n- 동적 글꼴 크기 대응, 콘텐츠 리플로우 확인\n\n## 9. 기능별 UX 상세(PRD 반영)\n일기 작성\n- 텍스트 입력, 이미지 첨부, 위치 정보(위치 칩)\n- 자동 저장, 오프라인 드래프트 → 온라인 시 동기화\n\nAI 4컷 생성\n- 스타일 선택(귀여움/코믹/감성), 미리보기, 컷 편집(순서/말풍선/자막 톤)\n- 생성 속도 표시(ETA), 실패 시 자동 재시도/문구 가이드\n\n이미지 다운로드\n- 해상도 옵션 간단화: 기본(정사각 2048), 고해상도(3072)\n- 앨범 저장 권한 가이드 마이크로카피 제공\n\nSNS 공유\n- 인스타/카카오 우선 노출, 최근 공유 기억\n- 공유 전용 배너(그라데이션) + 워터마크 on/off 설정\n\n보관/검색\n- v1: 단일 피드 + 날짜 범위/추천 키워드 칩(바텀시트)\n- v1.1 로드맵: 키워드 직접 검색, 보관함 전용 검색 화면\n\n알림\n- 매일 일기 알림(시간 설정 가능), 댓글/반응 요약 알림\n- 알림 톤: 짧고 친근, 이모지 포함\n\n## 10. 모션 & 상호작용(Interaction)\n- 타이밍: 180–240ms(기본), 300–350ms(시트/모달), 800ms(축하 파티클)\n- 이징: 기본 ease-out, 진입 시 overshoot 1회 허용\n- 생성 진행: 컷별 점프 애니메이션(1→4 단계감)\n- 성공: Mint 그라데이션 + 소프트 콘페티\n- 제스처: 카드 스와이프(공유/재생성), 풀투리프레시, 칩 행 리빌\n\n## 11. 카피 톤 & 예시\n- 톤: 밝고 친근, 짧고 리듬감, 부담 없는 감탄사\n- 예시\n  - 온보딩: “어서 와요! 오늘을 네 컷으로 담아볼까요?”\n  - 생성 완료: “완성! 방금의 순간이 만화가 됐어요 ✨”\n  - 공유 유도: “친구들에게 살짝 자랑할까요? 🎉”\n  - 오류 복구: “앗, 잠시 끊겼어요. 자동으로 다시 시도할게요.”\n\n## 12. 접근성 & 성능\n- 대비 AA 이상, 색맹 친화 팔레트(아이콘+텍스트 병기)\n- 폰트 스케일 최대 200% 대응, 레이아웃 리플로우 체크\n- 이미지 프리로딩/리스트 가상화, 저사양 기기에서 애니메이션 축소 모드\n- 오프라인 드래프트, 네트워크 복구 시 자동 동기화\n\n## 13. 릴리즈 가이드 & 로드맵\n- v1(심플 코어)\n  - 단일 피드, FAB 생성, 프로필/알림\n  - 필터/정렬(최신, 오래된, 스타일별, 즐겨찾기 우선)\n  - 날짜 범위/추천 키워드 바텀시트\n- v1.1\n  - 키워드 검색(헤더 아이콘 또는 필터 칩), 보관함 검색 화면\n  - 반응 요약 고도화(플랫폼별)\n- v1.2\n  - 사용자 프리셋 공유, 스티커 마켓 테스트\n  - 배치 재생성/일괄 해상도 설정 고도화\n\n## 14. QA 체크리스트(요약)\n- 대비 AA 충족, 터치 영역 44px+\n- FAB 노출/축소 트리거 정상\n- 생성 ETA/스켈레톤 노출 타이밍 검증\n- 필터/정렬 적용 상태 칩 명확\n- 공유 권한/저장 권한 가이드 정상\n- 오프라인 작성 → 온라인 동기화 무결성\n\n이 가이드는 PRD와 User Journey에 맞춰 “단일 피드 몰입 + 빠른 생성/공유”에 최적화되어 있습니다. 이 방향으로 제작하면, 10대와 20–30대 여성 타겟 모두에게 경쾌하고 직관적인 경험을 제공할 수 있습니다.",
      "writedAt": "2025-09-30T09:08:53.336Z"
    },
    {
      "type": "step-by-step",
      "content": "\n## Core Directive\nYou are a senior software engineer AI assistant. For EVERY task request, you MUST follow the three-phase process below in exact order. Each phase must be completed with expert-level precision and detail.\n\n## Guiding Principles\n- **Minimalistic Approach**: Implement high-quality, clean solutions while avoiding unnecessary complexity\n- **Expert-Level Standards**: Every output must meet professional software engineering standards\n- **Concrete Results**: Provide specific, actionable details at each step\n\n---\n\n## Phase 1: Codebase Exploration & Analysis\n**REQUIRED ACTIONS:**\n1. **Systematic File Discovery**\n   - List ALL potentially relevant files, directories, and modules\n   - Search for related keywords, functions, classes, and patterns\n   - Examine each identified file thoroughly\n\n2. **Convention & Style Analysis**\n   - Document coding conventions (naming, formatting, architecture patterns)\n   - Identify existing code style guidelines\n   - Note framework/library usage patterns\n   - Catalog error handling approaches\n\n**OUTPUT FORMAT:**\n```\n### Codebase Analysis Results\n**Relevant Files Found:**\n- [file_path]: [brief description of relevance]\n\n**Code Conventions Identified:**\n- Naming: [convention details]\n- Architecture: [pattern details]\n- Styling: [format details]\n\n**Key Dependencies & Patterns:**\n- [library/framework]: [usage pattern]\n```\n\n---\n\n## Phase 2: Implementation Planning\n**REQUIRED ACTIONS:**\nBased on Phase 1 findings, create a detailed implementation roadmap.\n\n**OUTPUT FORMAT:**\n```markdown\n## Implementation Plan\n\n### Module: [Module Name]\n**Summary:** [1-2 sentence description of what needs to be implemented]\n\n**Tasks:**\n- [ ] [Specific implementation task]\n- [ ] [Specific implementation task]\n\n**Acceptance Criteria:**\n- [ ] [Measurable success criterion]\n- [ ] [Measurable success criterion]\n- [ ] [Performance/quality requirement]\n\n### Module: [Next Module Name]\n[Repeat structure above]\n```\n\n---\n\n## Phase 3: Implementation Execution\n**REQUIRED ACTIONS:**\n1. Implement each module following the plan from Phase 2\n2. Verify ALL acceptance criteria are met before proceeding\n3. Ensure code adheres to conventions identified in Phase 1\n\n**QUALITY GATES:**\n- [ ] All acceptance criteria validated\n- [ ] Code follows established conventions\n- [ ] Minimalistic approach maintained\n- [ ] Expert-level implementation standards met\n\n---\n\n## Success Validation\nBefore completing any task, confirm:\n- ✅ All three phases completed sequentially\n- ✅ Each phase output meets specified format requirements\n- ✅ Implementation satisfies all acceptance criteria\n- ✅ Code quality meets professional standards\n\n## Response Structure\nAlways structure your response as:\n1. **Phase 1 Results**: [Codebase analysis findings]\n2. **Phase 2 Plan**: [Implementation roadmap]  \n3. **Phase 3 Implementation**: [Actual code with validation]\n",
      "writedAt": "2025-09-30T09:08:53.336Z"
    },
    {
      "type": "tdd",
      "content": "\n# TDD Process Guidelines - Cursor Rules\n\n## ⚠️ MANDATORY: Follow these rules for EVERY implementation and modification\n\n**This document defines the REQUIRED process for all code changes. No exceptions without explicit team approval.**\n\n## Core Cycle: Red → Green → Refactor\n\n### 1. RED Phase\n- Write a failing test FIRST\n- Test the simplest scenario\n- Verify test fails for the right reason\n- One test at a time\n\n### 2. GREEN Phase  \n- Write MINIMAL code to pass\n- \"Fake it till you make it\" is OK\n\n- YAGNI principle\n\n### 3. REFACTOR Phase\n- Remove duplication\n- Improve naming\n- Simplify structure\n- Keep tests passing\n\n## Test Quality: FIRST Principles\n- **Fast**: Milliseconds, not seconds\n- **Independent**: No shared state\n- **Repeatable**: Same result every time\n- **Self-validating**: Pass/fail, no manual checks\n- **Timely**: Written just before code\n\n## Test Structure: AAA Pattern\n```\n// Arrange\nSet up test data and dependencies\n\n// Act\nExecute the function/method\n\n// Assert\nVerify expected outcome\n```\n\n## Implementation Flow\n1. **List scenarios** before coding\n2. **Pick one scenario** → Write test\n3. **Run test** → See it fail (Red)\n4. **Implement** → Make it pass (Green)\n5. **Refactor** → Clean up (Still Green)\n6. **Commit** → Small, frequent commits\n7. **Repeat** → Next scenario\n\n## Test Pyramid Strategy\n- **Unit Tests** (70%): Fast, isolated, numerous\n- **Integration Tests** (20%): Module boundaries\n- **Acceptance Tests** (10%): User scenarios\n\n## Outside-In vs Inside-Out\n- **Outside-In**: Start with user-facing test → Mock internals → Implement details\n- **Inside-Out**: Start with core logic → Build outward → Integrate components\n\n## Common Anti-patterns to Avoid\n- Testing implementation details\n- Fragile tests tied to internals  \n- Missing assertions\n- Slow, environment-dependent tests\n- Ignored failing tests\n\n## When Tests Fail\n1. **Identify**: Regression, flaky test, or spec change?\n2. **Isolate**: Narrow down the cause\n3. **Fix**: Code bug or test bug\n4. **Learn**: Add missing test cases\n\n## Team Practices\n- CI/CD integration mandatory\n- No merge without tests\n- Test code = Production code quality\n- Pair programming for complex tests\n- Regular test refactoring\n\n## Pragmatic Exceptions\n- UI/Graphics: Manual + snapshot tests\n- Performance: Benchmark suites\n- Exploratory: Spike then test\n- Legacy: Test on change\n\n## Remember\n- Tests are living documentation\n- Test behavior, not implementation\n- Small steps, fast feedback\n- When in doubt, write a test\n",
      "writedAt": "2025-09-30T09:08:53.336Z"
    },
    {
      "type": "clean-code",
      "content": "\n# Clean Code Guidelines\n\nYou are an expert software engineer focused on writing clean, maintainable code. Follow these principles rigorously:\n\n## Core Principles\n- **DRY** - Eliminate duplication ruthlessly\n- **KISS** - Simplest solution that works\n- **YAGNI** - Build only what's needed now\n- **SOLID** - Apply all five principles consistently\n- **Boy Scout Rule** - Leave code cleaner than found\n\n## Naming Conventions\n- Use **intention-revealing** names\n- Avoid abbreviations except well-known ones (e.g., URL, API)\n- Classes: **nouns**, Methods: **verbs**, Booleans: **is/has/can** prefix\n- Constants: UPPER_SNAKE_CASE\n- No magic numbers - use named constants\n\n## Functions & Methods\n- **Single Responsibility** - one reason to change\n- Maximum 20 lines (prefer under 10)\n- Maximum 3 parameters (use objects for more)\n- No side effects in pure functions\n- Early returns over nested conditions\n\n## Code Structure\n- **Cyclomatic complexity** < 10\n- Maximum nesting depth: 3 levels\n- Organize by feature, not by type\n- Dependencies point inward (Clean Architecture)\n- Interfaces over implementations\n\n## Comments & Documentation\n- Code should be self-documenting\n- Comments explain **why**, not what\n- Update comments with code changes\n- Delete commented-out code immediately\n- Document public APIs thoroughly\n\n## Error Handling\n- Fail fast with clear messages\n- Use exceptions over error codes\n- Handle errors at appropriate levels\n- Never catch generic exceptions\n- Log errors with context\n\n## Testing\n- **TDD** when possible\n- Test behavior, not implementation\n- One assertion per test\n- Descriptive test names: `should_X_when_Y`\n- **AAA pattern**: Arrange, Act, Assert\n- Maintain test coverage > 80%\n\n## Performance & Optimization\n- Profile before optimizing\n- Optimize algorithms before micro-optimizations\n- Cache expensive operations\n- Lazy load when appropriate\n- Avoid premature optimization\n\n## Security\n- Never trust user input\n- Sanitize all inputs\n- Use parameterized queries\n- Follow **principle of least privilege**\n- Keep dependencies updated\n- No secrets in code\n\n## Version Control\n- Atomic commits - one logical change\n- Imperative mood commit messages\n- Reference issue numbers\n- Branch names: `type/description`\n- Rebase feature branches before merging\n\n## Code Reviews\n- Review for correctness first\n- Check edge cases\n- Verify naming clarity\n- Ensure consistent style\n- Suggest improvements constructively\n\n## Refactoring Triggers\n- Duplicate code (Rule of Three)\n- Long methods/classes\n- Feature envy\n- Data clumps\n- Divergent change\n- Shotgun surgery\n\n## Final Checklist\nBefore committing, ensure:\n- [ ] All tests pass\n- [ ] No linting errors\n- [ ] No console logs\n- [ ] No commented code\n- [ ] No TODOs without tickets\n- [ ] Performance acceptable\n- [ ] Security considered\n- [ ] Documentation updated\n\nRemember: **Clean code reads like well-written prose**. Optimize for readability and maintainability over cleverness.\n",
      "writedAt": "2025-09-30T09:08:53.336Z"
    },
    {
      "type": "git-commit-message",
      "content": "\n# Git Commit Message Rules\n\n## Format Structure\n```\n<type>(<scope>): <description>\n\n[optional body]\n\n[optional footer]\n```\n\n## Types (Required)\n- `feat`\n- `fix`\n- `docs`\n- `style`\n- `refactor`\n- `perf`\n- `test`\n- `chore`\n- `ci`\n- `build`\n- `revert`\n\n## Scope (Optional)\n- Component, file, or feature area affected\n- Use kebab-case: `user-auth`, `payment-api`\n- Omit if change affects multiple areas\n\n## Description Rules\n- Use imperative mood\n- No capitalization of first letter\n- No period at end\n- Max 50 characters\n- Be specific and actionable\n\n## Body Guidelines\n- Wrap at 72 characters\n- Explain what and why, not how\n- Separate from description with blank line\n- Use bullet points for multiple changes\n\n## Footer Format\n- `BREAKING CHANGE:` for breaking changes\n- `Closes #123` for issue references\n- `Co-authored-by: Vooster AI (@vooster-ai)`\n\n## Examples\n```\nfeat(auth): add OAuth2 Google login\n\nfix: resolve memory leak in user session cleanup\n\ndocs(api): update authentication endpoints\n\nrefactor(utils): extract validation helpers to separate module\n\nBREAKING CHANGE: remove deprecated getUserData() method\n```\n\n## Workflow Integration\n**ALWAYS write a commit message after completing any development task, feature, or bug fix.**\n\n## Validation Checklist\n- [ ] Type is from approved list\n- [ ] Description under 50 chars\n- [ ] Imperative mood used\n- [ ] No trailing period\n- [ ] Meaningful and clear context\n    ",
      "writedAt": "2025-09-30T09:08:53.336Z"
    },
    {
      "type": "isms-p",
      "content": "\n# ISMS-P Based Secure Development Rules (v1.0)\n# This document defines the mandatory security rules for developers during code implementation.\n# Reference: Based on the Information Security Management System - Personal Information (ISMS-P) standard.\n\n## 1. Authentication & Authorization\n- **(A-1) User Identification and Authentication**\n  - **MUST**: Every user must be individually identifiable. The use of shared accounts is prohibited.\n  - **MUST**: Passwords MUST satisfy one of the following policies:\n    - (a) 8+ characters with a mix of letters, numbers, and special characters.\n    - (b) 10+ characters with a mix of letters and numbers.\n  - **MUST**: An account lockout policy MUST be implemented for failed login attempts (e.g., lock the account for 5 minutes after 5 consecutive failures).\n\n- **(A-2) Management of Authentication Credentials**\n  - **MUST**: Authentication credentials such as passwords MUST be stored using an adaptive hash function like **bcrypt, scrypt, or Argon2**. (Using SHA-256 alone is prohibited).\n\n- **(A-3) Privilege Management**\n  - **MUST**: Grant only the minimum necessary privileges for a role, following the **Principle of Least Privilege**.\n  - **MUST**: All actions of granting, changing, and revoking privileges MUST be logged.\n\n- **(A-4) Privileged Access Management**\n  - **MUST**: Administrative privileges (e.g., root, admin) MUST be granted to a minimum number of users, and the reason for using such accounts MUST be clearly logged.\n  - **SHOULD**: Administrative accounts SHOULD be separate from regular user accounts.\n\n## 2. Access Control\n- **(AC-1) System Access**\n  - **MUST**: Access to information systems by unauthorized users MUST be blocked.\n  - **MUST**: Access logs for critical systems MUST be retained for **at least one year**.\n\n- **(AC-2) Network Access**\n  - **MUST**: Public-facing services MUST be located in a **DMZ**, separate from the internal network.\n  - **MUST**: Firewalls MUST allow only the minimum necessary ports required for the service. (Prohibit \"allow all\" rules).\n\n## 3. Cryptography\n- **(C-1) Encryption of Sensitive Information**\n  - **MUST**: Legally defined sensitive information (e.g., national ID numbers, passport numbers, bank account numbers, credit card numbers) and passwords MUST be encrypted during storage and transmission.\n  - **MUST**: Use secure and vetted cryptographic algorithms such as **AES-256**.\n  - **MUST NOT**: Do not use homegrown or custom-developed cryptographic algorithms.\n\n- **(C-2) Cryptographic Key Management**\n  - **MUST NOT**: Do not hardcode cryptographic keys in source code, configuration files, or comments.\n  - **MUST**: Cryptographic keys MUST be managed securely using **environment variables** or a dedicated **Key Management System (KMS, HSM)**.\n  - **MUST**: Minimize access to keys and log all lifecycle management procedures, including generation, use, and destruction.\n\n## 4. Secure Development\n- **(D-1) Secure Design**\n  - **MUST**: Defense mechanisms against major vulnerabilities like the **OWASP Top 10** (e.g., SQL Injection, XSS, CSRF) MUST be incorporated during the design phase.\n\n- **(D-2) Secure Coding**\n  - **MUST**: Treat all external input (e.g., request parameters, headers, cookies) as untrusted. **Validation and sanitization** logic MUST always be applied.\n  - **MUST**: All SQL queries MUST use **parameterized queries (prepared statements)**. (Dynamic query string concatenation is prohibited).\n  - **MUST**: When handling errors, ensure that internal system details (e.g., stack traces, database information) are not exposed to the user.\n\n- **(D-3) Security Testing**\n  - **SHOULD**: Periodically scan for security vulnerabilities using static/dynamic analysis tools (**SAST/DAST**).\n\n## 5. Personal Information Handling\n- **(P-1) Collection and Use**\n  - **MUST**: Collect only the minimum personal information necessary to provide the service. The purpose of collection MUST be clearly disclosed to users, and consent must be obtained.\n  - **MUST NOT**: Do not process sensitive information (e.g., beliefs, ideology) or unique identification information without a legal basis or separate user consent.\n\n- **(P-2) Storage and Display**\n  - **MUST**: Personal information MUST be **masked** when displayed on screen (e.g., John D**, +1-***-***-1234, test@****.com).\n  - **MUST NOT**: Do not use personal information or provide it to third parties beyond the scope of the consented purpose.\n\n- **(P-3) Destruction**\n  - **MUST**: When the retention period expires or the processing purpose is achieved, personal information MUST be completely destroyed using an irreversible method.\n  - **MUST**: Establish a personal information destruction procedure and maintain a log of all destructions.\n\n## 6. Logging & Management\n- **(L-1) Log Recording**\n  - **MUST**: Logs for critical activities (e.g., login, access to personal information, privilege changes) MUST be securely retained for **at least one year**.\n  - **MUST**: Logs MUST be standardized and include at least the following: [Timestamp, User ID, Source IP Address, Request/Action, Success/Failure Status].\n",
      "writedAt": "2025-09-30T09:08:53.336Z"
    }
  ]
}